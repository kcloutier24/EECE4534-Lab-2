## Hardware Timer PWM

In the last sections used software implementations of PWM (busy loop and
software timer). These implementations have their own limitations. Now,
we will explore using a dedicated HW peripheral (AXI TIMER v2.0) to
create the PWM signal.

1.  Copy the skeleton file `pwm_skel/pwm.c` into `pwm_timer.c` for your
    hardware timer-based implementation. Add, and commit the unmodified
    file into your repository to have a starting point.

2.  Add functions to control the AXI Timer. Remove unnecessary code.
    Consult the Hardware mapping document and the AXI Timer data sheet.
    Configure the AXI Timer peripheral to use itâ€™s Timer 0 and Timer 1
    for generating PWM with the following characteristics:

    -   Frequency of 1 kHz
    -   Duty cycle of 50%

    Note that both timers (Timer 0 and Timer 1) need to get enabled at
    the same time to start the PWM.

3.  The signal that drives LED LD0 on the board is multiplexed so that
    we can see either the GPIO signal controlled by the LED AXI GPIO
    peripheral or the PWM signal generated by Timer 0. By default, the
    GPIO signal is routed to the LED. To change the routing and display
    the PWM signal generated by the timer, you must select the source
    using the `aximux` peripheral. To control the signal source, write
    to the file located in the sysfs subsystem
    (`/sys/class/aximux/aximux0/control/source` as follows:

    | **Value** | **LED0 driven by** |
    |:---------:|:-------------------|
    |     0     | LED AXI GPIO       |
    |     1     | Timer 0 PWM output |

4.  Validate that PWM is produced properly by visually inspecting the
    LED. Measure the timing with `pulsecap1`. Report on any
    discrepancies found. Save the raw results for later CDF analysis.

5.  Validate how overall system load (using `stress-ng`) affects the PWM
    quality. Measure with `pulsecap1`, reason about your observations.
    Save the raw results for later CDF analysis.

6.  Commit any modified files into your repository.